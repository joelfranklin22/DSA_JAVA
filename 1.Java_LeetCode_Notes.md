# Java LeetCode Solutions Notes

## 1. Two Sum - Using HashMap

**Example:** `a[]={2,7,11,15}; target=9;`

```java
for(int i = 0; i < len; i++) {
    current_value = nums[i];
    // Current Value is Subtracted From Target to Find the Two Numbers
    target_value = target - current_value;
    // Hashmap Check Whether target value is present in Map
    if (m1.containsKey(target_value))
        return new int[]{m1.get(target_value), i}; // Returns value in Array Format using get()
    m1.put(current_value, i); // If value not found add value to Map
}
return new int[]{-1, -1};
```

**Time Complexity:** O(n)  
**Space Complexity:** O(n)

---

## 2. Median of Two Sorted Arrays

```java
int c[] = new int[len1 + len2];
// Merge Two Array into Single with Single Loop
while (k < len3) {
    if (j < len1) { // Merge First Array
        c[k] = nums1[j];
        k++;
        j++;
    }
    if (i < len2) { // Merging Second Array
        c[k] = nums2[i];
        k++;
        i++;
    }
}
// Sorting Merged Array
Arrays.sort(c);
int mid = len3 / 2; // Finds Mid
if (len3 % 2 == 0) // Checks Whether the length is Odd or Even
    return (double)(c[mid] + c[mid - 1]) / 2;
else
    return c[mid];
```

**Time Complexity:** O((m + n) log(m + n))  
**Space Complexity:** O(m + n)

---

## 3. H-Index

```java
// Creating New Array to Check Counting of Every Number..
int b[] = new int[len + 1];

// Loops Checks for Counting of Every Number
for (i = 0; i < len; i++) {
    if (a[i] >= len)
        b[len] += 1; // Add One Everytime
    else
        b[a[i]] += 1; // Put One in Same Number Index of Another Array
}

int total = 0;
// Loops Check for the Number Higher than H index and Citation
for (h = len; h >= 0; h--) {
    total += b[h];
    if (total >= h)
        return h;
}
return 0;
```

**Time Complexity:** O(n)  
**Space Complexity:** O(1)

---

## 4. First and Last Position of Elements in Sorted Array (Binary Search Rule)

```java
// First it Checks for First Position then Last Position will be Checked
while (start <= end) {
    mid = (start + end) / 2;
    if (nums[mid] == target) {
        index = mid; // Copy the value of mid to index for returning Position
        if (findFirst) // At First it checks for First Position
            end = mid - 1;
        else
            start = mid + 1;
    } else if (nums[mid] > target) {
        end = mid - 1;
    } else {
        start = mid + 1;
    }
}
return index;

// Usage
int first = s.searchRange(a, target, true);
if (first == -1) {
    System.out.println("[-1, -1]");
} else {
    int last = s.searchRange(a, target, false);
    System.out.println("Result: [" + first + ", " + last + "]");
```

**Time Complexity:** O(log n)  
**Space Complexity:** O(1)

---

## 5. Search Element in Rotated Array (Binary Search Rule)

```java
while (start <= end) {
    mid = (start + end) / 2;
    if (nums[mid] == target)
        return mid;

    // Checks Whether the Number is Left Side or Not
    if (nums[start] <= nums[mid]) {
        // Checks the Left Side is Sorted Order
        if (nums[start] <= target && target < nums[mid])
            end = mid - 1;
        else
            start = mid + 1;
    } else {
        // Right Side Sorted
        if (nums[mid] < target && target <= nums[end])
            start = mid + 1;
        else
            end = mid - 1;
    }
}
return -1;
```

**Time Complexity:** O(log n)  
**Space Complexity:** O(1)

`--------------------------------------------------------------------------------------------`

## 6.Minimum Element in Rotated Array

```java
    // int a[]={11,13,15,17};
    // if the start is less than end then that is minimum element
     if (nums[start] <= nums[end])
            return nums[start];
        while (start <= end)
        {
            int mid = (start+end)/2;
            // Checks Whether the mid is less than Left side of Mid
            if (mid > 0 && nums[mid] < nums[mid - 1])
                return nums[mid];
            // Checks Whether the mid is Greater than right side of Mid
            if (mid < nums.length - 1 && nums[mid] > nums[mid + 1])
                return nums[mid + 1];
            // This conditin checks whether to move the start or end to left or right
            if (nums[mid] >= nums[start])
                start = mid + 1;
            else
                end = mid - 1;
        }

        return -1;
```

**Time complexity:** **Space complexity:**
**O(Log n)** **O(1)**

## 7.Maximum Product SubArray

```JAVA
// Assign 0 to currMax,Min,MaxProduct
        for (int i = 1; i < nums.length; i++) 
        {
             int currentNum = nums[i];//Assign Current Number
            //  this conditions if the negative multiply with negative number it can be maxproduct
            if (currentNum < 0) 
            {
                int temp = currMax;
                currMax = currMin;
                currMin = temp;
            }
            // Checks the  currect max and min to product them
        currMax = Math.max(currentNum, currMax * currentNum);
        currMin = Math.min(currentNum, currMin * currentNum);
        maxProduct = Math.max(maxProduct, currMax);
        }
        return maxProduct;
```

***Time Complexity***                           ***Space Complexity***
O(n)                                                O(1)

## 8.Find Peak Element (BinarySearch)

```JAVA
    // For this Problem When the left and right equal to each other left will be retured...
     while (left < right)
        {
            int mid = left + (right - left) / 2;
            // To Find Peak Element the Element Must be greater than their neighbours
            if (nums[mid] > nums[mid + 1])  
                right = mid;     
            else   
                left = mid + 1;
        }
        return left;
```

***Time Complexity***                          ***Space Complexity***
O(log n)                                           O(1)

## 9.Two Sum II Sorted Array(BinarySearch)

```JAVA
        while (left < right) 
        {
            int sum = numbers[left] + numbers[right];
            if (sum == target) 
                return new int[]{left + 1, right + 1};
            else if (sum < target) 
                left++; 
             else 
                right--; 
        }
```

***Time Complexity**                                ***Space Complexity***
O(log n)                                                O(1)

## 10.Search Insert Position(BinarySearch)

```JAVA
        //Need to find a Element or Position that is missing inits position or in the array
        while(st<=end)
        {
            mid=(st+end)/2;
            if(nums[mid]==target)
                return mid;
            else if(nums[mid]>target)
                    end=mid-1;
            else    
                    st=mid+1;;
        }
        return st;
```

***Time Complexity***                                       ***Space Complexity***
O(log n)                                                        O(1)

## 11.Contains Duplicate III [HashMap] [Bucket Sort Concept]

``` i != j, ```
``` abs(i - j) <= indexDiff. ```
``` abs(nums[i] - nums[j]) <= valueDiff ```

```JAVA

       if (valueDiff < 0 || indexDiff <= 0 || nums == null || nums.length == 0) return false;
        Map<Long, Long> m1 = new HashMap<>();
        long size = (long) valueDiff + 1;

        for (int i = 0; i < nums.length; i++) {
            long num = (long) nums[i];
            long bucketId = getBucketId(num, size);

            // Check same bucket
            if (m1.containsKey(bucketId))
                return true;

            // Check adjacent buckets
            if (m1.containsKey(bucketId - 1) && Math.abs(num - m1.get(bucketId - 1)) <= valueDiff)
                return true;

            if (m1.containsKey(bucketId + 1) && Math.abs(num - m1.get(bucketId + 1)) <= valueDiff)
                return true;

            // Insert current element into its bucket
            m1.put(bucketId, num);

            // Maintain sliding window of size indexDiff
            if (i >= indexDiff) {
                long oldBucketId = getBucketId((long) nums[i - indexDiff], size);
                m1.remove(oldBucketId);
            }
        }

```

***Time Complexity***                                   ***Space Complexity***
O(n)                                                        O(n)

### 12.Remove Duplicates from Sorted Array with two pointer

```JAVA
        for (int i = 1; i < nums.length; i++)
        {   
            if (nums[i] != nums[k - 1]) 
            {
                nums[k] = nums[i];
                k++;
            }
        }

```

***Time Complexity***                                   ***Space Complexity***
O(n)                                                     O(1)

### 13.First Missing Positive

```JAVA
    
        for (int i = 0; i < n; i++) 
        { 
            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) 
            {
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }
        for (int i = 0; i < n; i++) 
        {
            if (nums[i] != i + 1)
                return i + 1;
        }

```

***Time Complexity***                               ***Space Complexity***
O(n)                                                    O(1)

### 13.Rotate Array

```JAVA
        // if the rotate value is greater than length of array we use modulo
        //example if rotate is 24 then len is 6 then 24%6 is 4 we can rotate the array by 4 times
        int rotate=k%len;
        // First Swap the First Half from the Rotate Value
        swap(nums,0,len-rotate-1);
        // Swap Second Half of Rotate Value
        swap(nums,len-rotate,len-1);
        // Swap the Array
        swap(nums,0,len-1);
        
        // Swap Function called to swap the array
        while(start<=end)
        {
            temp=nums[start];
            nums[start]=nums[end];
            nums[end]=temp;
            start++;
            end--;
        }

```

***Time Complexity***                               ***Space Complexity***
O(n)                                                    O(1)
